# -*- coding: utf-8 -*-
"""final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TqJOIKVTj2JGaTDqH77TREtz3IJWO93k
"""

import numpy as np
import cv2
from matplotlib import pyplot as plt
from tqdm import tqdm
#画像数
img_times=158
#画素数
height=720
width=1280
picture=np.zeros([img_times,height,width,4])
# 画像を読込
for count in tqdm(range(img_times)):
  if(count<10):
    name_str='00'+str(count)
  elif(count<100):
    name_str='0'+str(count)
  else:
    name_str=str(count)
  filename = 'crossing/img'+name_str+'.png'
  img = cv2.imread(filename, -1)
  picture[count]=img
  picture[count,:,:]=picture[count,:,:].astype(np.float32)/255.0
  #出力画像の格納
out_img=np.zeros([height,width,4])
#画像の合成
for height_count in tqdm(range(height)):
  for width_count in range(width):
    out_img[height_count,width_count,0]=np.average(picture[:,height_count,width_count,0])
    out_img[height_count,width_count,1]=np.average(picture[:,height_count,width_count,1])
    out_img[height_count,width_count,2]=np.average(picture[:,height_count,width_count,2])
    out_img[height_count,width_count,3]=np.average(picture[:,height_count,width_count,3])

#0~255までの表記戻す
img_8bit=256*out_img
#0未満を0、255より大きい数を255にする
img_8bit=np.clip(img_8bit,0,255)
#データの型をuint8にする
img_8bit=img_8bit.astype(np.uint8)

#ファイル書き込み
cv2.imwrite('output.png',img_8bit)

!mkdir ETrobo

import cv2

cap = cv2.VideoCapture('./ETrobo/ETrobo_2019.mp4')
print(type(cap))
# <class 'cv2.VideoCapture'>

print(cap.isOpened())
# True
print(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
# 640.0

print(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
# 360.0

print(cap.get(cv2.CAP_PROP_FPS))
# 29.97002997002997

print(cap.get(cv2.CAP_PROP_FRAME_COUNT))
# 360.0
print(cap.get(cv2.CAP_PROP_FRAME_COUNT) / cap.get(cv2.CAP_PROP_FPS))
print(cap.set(cv2.CAP_PROP_FRAME_WIDTH, 320))
# False

print(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
# 640.0
print(cap.get(cv2.CAP_PROP_POS_FRAMES))
# 0.0

print(cap.set(cv2.CAP_PROP_POS_FRAMES, 100))
# True

print(cap.get(cv2.CAP_PROP_POS_FRAMES))
# 100.0

import cv2

cap = cv2.VideoCapture('./ETrobo/ETrobo_2019.mp4')
print(type(cap))
# <class 'cv2.VideoCapture'>

print(cap.isOpened())
# True

print(cap.get(cv2.CAP_PROP_POS_FRAMES))
# 0.0

print(cap.get(cv2.CAP_PROP_POS_MSEC))
# 0.0

ret, frame = cap.read()

print(ret)
# True

print(type(frame))
# <class 'numpy.ndarray'>

print(frame.shape)
# (360, 640, 3)

print(cap.get(cv2.CAP_PROP_POS_FRAMES))
# 1.0

print(cap.get(cv2.CAP_PROP_POS_MSEC))
# 33.36666666666667

print(1 / cap.get(cv2.CAP_PROP_FPS) * 1000)
# 33.36666666666667

cap.set(cv2.CAP_PROP_POS_FRAMES, 200)
print(cap.get(cv2.CAP_PROP_POS_FRAMES))
# 100.0

ret, frame = cap.read()

print(ret)
# True

print(cap.get(cv2.CAP_PROP_POS_FRAMES))
# 101.0

print(cap.get(cv2.CAP_PROP_POS_MSEC))
# 3370.0333333333333

cap.set(cv2.CAP_PROP_POS_FRAMES, cap.get(cv2.CAP_PROP_FRAME_COUNT))
print(cap.get(cv2.CAP_PROP_POS_FRAMES))
# 360.0

ret, frame = cap.read()

print(ret)
# False

print(frame)
# None

print(cap.get(cv2.CAP_PROP_POS_FRAMES))
# 360.0

cap.set(cv2.CAP_PROP_POS_FRAMES, 1000)
print(cap.get(cv2.CAP_PROP_POS_FRAMES))
# 360.0

import cv2
import numpy as np
from matplotlib import pyplot as plt
from tqdm import tqdm
cap = cv2.VideoCapture('./ETrobo/ETrobo_2019.mp4')
pictures_times=0
height=1080
width=1920
picture_deta=np.zeros([141,height,width,3])
for time_now in tqdm(range(47)):
  for time_m_now in range(3):
    cap.set(cv2.CAP_PROP_POS_FRAMES, time_now*3+time_m_now)
    ret, frame = cap.read()
    picture_deta[pictures_times]=frame.astype(np.float32)/255.0
    plt.imshow(frame)
    plt.show()
    pictures_times=pictures_times+1;
ET_out_img=np.zeros([height,width,3])
for height_count in tqdm(range(height)):
  for width_count in range(width):
    ET_out_img[height_count,width_count,0]=np.average(picture_deta[:,height_count,width_count,0])
    ET_out_img[height_count,width_count,1]=np.average(picture_deta[:,height_count,width_count,1])
    ET_out_img[height_count,width_count,2]=np.average(picture_deta[:,height_count,width_count,2])
#0~255までの表記戻す
ET_img_8bit=256*ET_out_img
#0未満を0、255より大きい数を255にする
ET_img_8bit=np.clip(ET_img_8bit,0,255)
#データの型をuint8にする
ET_img_8bit=ET_img_8bit.astype(np.uint8)

#ファイル書き込み
cv2.imwrite('ET_output.png',ET_img_8bit)

picture_deta.shape

#0~255までの表記戻す
ET_57_img_8bit=256*picture_deta[57]
#0未満を0、255より大きい数を255にする
ET_57_img_8bit=np.clip(ET_57_img_8bit,0,255)
#データの型をuint8にする
ET_57_img_8bit=ET_57_img_8bit.astype(np.uint8)
plt.imshow(picture_deta[57])
plt.show()
#ファイル書き込み
cv2.imwrite('ET_57_output.png',ET_57_img_8bit)

#0~255までの表記戻す
ET_141_img_8bit=256*picture_deta[140]
#0未満を0、255より大きい数を255にする
ET_141_img_8bit=np.clip(ET_141_img_8bit,0,255)
#データの型をuint8にする
ET_141_img_8bit=ET_141_img_8bit.astype(np.uint8)
plt.imshow(picture_deta[140])
plt.show()
#ファイル書き込み
cv2.imwrite('ET_141_output.png',ET_141_img_8bit)

